From 5ba4ed1d0fb6c8d5109cf2fcc44841ddd485a979 Mon Sep 17 00:00:00 2001
From: Jiri Konecny <jkonecny@redhat.com>
Date: Mon, 12 Aug 2019 10:28:37 +0200
Subject: [PATCH] Set timeout for all session.get calls

Based on the documentation for python requests library we should always
specify the timeout command to avoid long timeouts.

See:
https://3.python-requests.org/user/advanced/#timeouts

Set the timeout parameter to all the calls.

Reported-by: HangyuTian (github)
---
 pyanaconda/payload/dnfpayload.py                  | 3 ++-
 pyanaconda/payload/__init__.py                    | 3 ++-
 pyanaconda/payload/livepayload.py                 | 8 +++++---
 3 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/pyanaconda/payload/dnfpayload.py b/pyanaconda/payload/dnfpayload.py
index 477538e6c6..663387b4e1 100644
--- a/pyanaconda/payload/dnfpayload.py
+++ b/pyanaconda/payload/dnfpayload.py
@@ -1450,7 +1450,8 @@ def _download_repoMD(self, method):
         for url in self._urls:
             try:
                 result = session.get("%s/repodata/repomd.xml" % url, headers=headers,
-                                     proxies=proxies, verify=sslverify)
+                                     proxies=proxies, verify=sslverify,
+                                     timeout=constants.NETWORK_CONNECTION_TIMEOUT)
                 if result.ok:
                     repomd = result.text
                     break
--- a/pyanaconda/payload/__init__.py      2018-09-13 23:26:54.000000000 +0800
+++ b/pyanaconda/payload/__init__.py     2019-08-14 16:41:01.134000000 +0800
@@ -45,7 +45,7 @@

 from pyanaconda.core.constants import DRACUT_ISODIR, DRACUT_REPODIR, DD_ALL, DD_FIRMWARE, \
     DD_RPMS, INSTALL_TREE, ISO_DIR, THREAD_STORAGE, THREAD_PAYLOAD, THREAD_PAYLOAD_RESTART, \
-    THREAD_WAIT_FOR_CONNECTING_NM, PayloadRequirementType, GRAPHICAL_TARGET, TEXT_ONLY_TARGET
+    THREAD_WAIT_FOR_CONNECTING_NM, PayloadRequirementType, GRAPHICAL_TARGET, TEXT_ONLY_TARGET, NETWORK_CONNECTION_TIMEOUT
 from pyanaconda.modules.common.constants.services import SERVICES
 from pykickstart.constants import GROUP_ALL, GROUP_DEFAULT, GROUP_REQUIRED
 from pyanaconda.flags import flags
@@ -734,7 +734,8 @@
     def _download_treeinfo_file(self, url, file_name, headers, proxies, verify):
         try:
             result = self._session.get("%s/%s" % (url, file_name), headers=headers,
-                                       proxies=proxies, verify=verify)
+                                       proxies=proxies, verify=verify,
+                                       timeout=NETWORK_CONNECTION_TIMEOUT)
             # Server returned HTTP 4XX or 5XX codes
             if result.status_code >= 400 and result.status_code < 600:
                 log.info("Server returned %i code", result.status_code)
diff --git a/pyanaconda/payload/livepayload.py b/pyanaconda/payload/livepayload.py
index 79ad6b4d69..a96e8e7948 100644
--- a/pyanaconda/payload/livepayload.py
+++ b/pyanaconda/payload/livepayload.py
@@ -47,7 +47,7 @@
 from pyanaconda.payload import ImagePayload, PayloadSetupError, PayloadInstallError
 
 from pyanaconda.core.constants import INSTALL_TREE, THREAD_LIVE_PROGRESS
-from pyanaconda.core.constants import IMAGE_DIR, TAR_SUFFIX
+from pyanaconda.core.constants import IMAGE_DIR, TAR_SUFFIX, NETWORK_CONNECTION_TIMEOUT
 
 from pyanaconda.core import util
 
@@ -309,7 +309,8 @@ def _setup_url_image(self):
 
         error = None
         try:
-            response = self._session.get(self.data.method.url, proxies=self._proxies, verify=True)
+            response = self._session.get(self.data.method.url, proxies=self._proxies, verify=True,
+                                         timeout=NETWORK_CONNECTION_TIMEOUT)
 
             # At this point we know we can get the image and what its size is
             # Make a guess as to minimum size needed:
@@ -328,7 +328,9 @@
             log.info("Starting image download")
             with open(self.image_path, "wb") as f:
                 ssl_verify = not self.data.method.noverifyssl
-                response = self._session.get(self.data.method.url, proxies=self._proxies, verify=ssl_verify, stream=True)
+                response = self._session.get(self.data.method.url, proxies=self._proxies,
+                                            verify=ssl_verify, stream=True,
+                                            timeout=NETWORK_CONNECTION_TIMEOUT)
                 total_length = response.headers.get('content-length')
                 if total_length is None:  # no content length header
                     # just download the file in one go and fake the progress reporting once done

